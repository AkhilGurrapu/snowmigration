-- Get lineage with size information
WITH lineage_objects AS (
    SELECT 
        SOURCE_OBJECT_NAME,
        SOURCE_OBJECT_DOMAIN,
        DISTANCE
    FROM TABLE(
        SNOWFLAKE.CORE.GET_LINEAGE(
            'PROD_DB.MART_INVESTMENTS_BOLT.VW_TRANSACTION_ANALYSIS',
            'TABLE',
            'UPSTREAM',
            5
        )
    )
    WHERE SOURCE_OBJECT_NAME IS NOT NULL
),
object_sizes AS (
    SELECT 
        l.SOURCE_OBJECT_NAME,
        l.SOURCE_OBJECT_DOMAIN,
        l.DISTANCE,
        t.TABLE_CATALOG,
        t.TABLE_SCHEMA,
        t.TABLE_NAME,
        s.ACTIVE_BYTES,
        s.TIME_TRAVEL_BYTES,
        s.FAILSAFE_BYTES,
        (COALESCE(s.ACTIVE_BYTES, 0) + 
         COALESCE(s.TIME_TRAVEL_BYTES, 0) + 
         COALESCE(s.FAILSAFE_BYTES, 0)) AS TOTAL_BYTES,
        ROUND(TOTAL_BYTES / 1024 / 1024 / 1024, 3) AS SIZE_GB,
        t.ROW_COUNT
    FROM lineage_objects l
    LEFT JOIN SNOWFLAKE.ACCOUNT_USAGE.TABLES t
        ON l.SOURCE_OBJECT_NAME = CONCAT(t.TABLE_CATALOG, '.', t.TABLE_SCHEMA, '.', t.TABLE_NAME)
        AND t.DELETED IS NULL
    LEFT JOIN SNOWFLAKE.ACCOUNT_USAGE.TABLE_STORAGE_METRICS s
        ON t.TABLE_CATALOG = s.TABLE_CATALOG
        AND t.TABLE_SCHEMA = s.TABLE_SCHEMA
        AND t.TABLE_NAME = s.TABLE_NAME
        AND s.DELETED = FALSE
    QUALIFY ROW_NUMBER() OVER (PARTITION BY l.SOURCE_OBJECT_NAME ORDER BY s.ACTIVE_BYTES DESC) = 1
)
SELECT 
    SOURCE_OBJECT_NAME,
    SOURCE_OBJECT_DOMAIN,
    DISTANCE,
    ROW_COUNT,
    SIZE_GB,
    ROUND(ACTIVE_BYTES / 1024 / 1024 / 1024, 2) AS ACTIVE_GB,
    ROUND(TIME_TRAVEL_BYTES / 1024 / 1024 / 1024, 2) AS TIME_TRAVEL_GB,
    ROUND(FAILSAFE_BYTES / 1024 / 1024 / 1024, 2) AS FAILSAFE_GB
FROM object_sizes
ORDER BY SIZE_GB DESC;

-- Get total size summary
SELECT 
    COUNT(*) AS TOTAL_OBJECTS,
    SUM(ROW_COUNT) AS TOTAL_ROWS,
    ROUND(SUM(SIZE_GB), 2) AS TOTAL_SIZE_GB,
    ROUND(SUM(SIZE_GB) / 1024, 3) AS TOTAL_SIZE_TB,
    ROUND(MAX(SIZE_GB), 2) AS LARGEST_OBJECT_GB
FROM object_sizes;
